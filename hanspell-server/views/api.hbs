<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Highlighter</title>
  <script src="https://cdn.jsdelivr.net/npm/@editorjs/editorjs@latest"></script>
  <style>
    .highlight-overlay {
      position: relative;
      display: inline-block;
      background-color: rgba(255, 0, 0, 0.3); /* 투명도 조절 가능 */
      padding: 2px;
      border-radius: 2px;
    }
  </style>
</head>
<body>
<div id="editorjs"></div>
<button onclick="highlightErrors()">Highlight Errors</button>

<script src="./myEditor.js"></script>
<script src="./spellCheck.js"></script>
<script src="./utils.js"></script>
<script>
  let previousBlockIndex = 0; // 이전 입력 텍스트 저장 변수

  // TODO: 에디터 위에서만 동작하도록 수정하기
  // 시작시 등록하는 EventListeners
  function addGlobalEventListeners() {
    document.addEventListener('keydown', handleGlobalKeydown);
    document.addEventListener('click', handleGlobalClick);
  }

  // TODO: 블럭의 수가 줄어들었을 때 previous 오류 수정하기
  // keydown 이벤트 검사하기
  function handleGlobalKeydown(event) {
    const blockIndex = myToolInstance.getCurrentBlockIndex();
    const cursorPosition = window.getSelection().getRangeAt(0).startOffset;
    console.log(`Block index: ${blockIndex}, Cursor position: ${cursorPosition}`);
    // 엔터쳐서 position이 0이면, 다음 줄 넘긴건지 확인
    if (blockIndex !== -1 && previousBlockIndex !== blockIndex) {
      isEndWithEnter();
    } else {
      // 아니면 문장부호? 문장의 끝을 감지하여 메시지를 출력하는 로직 추가
      isEndWithMarks(event, blockIndex);
    }
    previousBlockIndex = blockIndex;
  }

  // 문장 부호로 끝났다면 맞춤법 요청, 색칠, 커서 옮기기
  async function isEndWithMarks(event, blockIndex) {
    if (marks.includes(event.key)) {
      const currentText = event.target.innerText;
      // TODO: 전체 블럭 문장들이 아니라, 특정 문장으로만 해야할까?
      // 맞춤법 요청, 색칠,
      const result = await spellCheck(currentText + event.key);
      const block = myToolInstance.getBlockByIndex(blockIndex);
      await highlightErrors(block, result);
      moveCursorToEnd(document.querySelector(
          `.ce-block[data-id="${block.id}"] .ce-block__content .ce-paragraph.cdx-block`,
      ));
    }
  }

  // 엔터로 줄바꿈했다면, 이전 블럭 검사 후 색칠
  async function isEndWithEnter() {
    const previousBlock = myToolInstance.getBlockByIndex(previousBlockIndex);
    const result = await spellCheck(previousBlock.holder.innerText);
    highlightErrors(previousBlock, result);
  }

  // 클릭으로 이동했을 때
  async function handleGlobalClick(event) {
    const currentBlockIndex = myToolInstance.getCurrentBlockIndex();
    if (currentBlockIndex !== -1 && previousBlockIndex !== currentBlockIndex) {
      console.log('block changed', currentBlockIndex, '->', previousBlockIndex);
      const previousBlock = myToolInstance.getBlockByIndex(previousBlockIndex);
      const result = await spellCheck(previousBlock.holder.innerText);
      highlightErrors(previousBlock, result);
    }
    previousBlockIndex = currentBlockIndex;
  }

  // 결과 창 알림 TODO: 추후 팝업으로 보여주기
  function showSuggestions(suggestions, info) {
    alert('Suggestions: ' + suggestions + '\nInfo: ' + info);
  }

  /**
   * 커서를 블럭 마지막으로 보내기
   * @param element
   */
  function moveCursorToEnd(element) {
    const range = document.createRange();
    const selection = window.getSelection();
    range.selectNodeContents(element);
    range.collapse(false);
    selection.removeAllRanges();
    selection.addRange(range);
  }

  // 맞춤법 검사 결과로 block 색칠하기
  function highlightErrors(block, errors) {
    // 현재 블록의 텍스트에서 <span> 태그 제거
    let content = block.holder.innerText;
    console.log('before', content);
    content = removeSpan(content);
    errors.forEach(error => {
      const token = error.token;
      const escapedToken = escapeRegExp(token); // 토큰 이스케이프 처리
      const suggestions = escapeRegExp(error.suggestions.join(', ')); // 배열 하나로 합치기
      const info = escapeRegExp(error.info.replace(/\n/g, ' ')); // suggestions에 엔터 제거
      // TODO: 정규식으로 대체가 아니라 앞에서부터 토큰 검사해서 맞는거 치기
      const regex = new RegExp(`(${escapedToken})`, 'g');
      content = content.replace(regex,
          `<span class="highlight-overlay" onclick="showSuggestions('${suggestions}', '${info}')">$1</span>`);
    });

    editor.blocks.update(block.id, {
      text: content,
    });
  }
</script>
</body>
</html>
