<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Highlighter</title>
  <script src="https://cdn.jsdelivr.net/npm/@editorjs/editorjs@latest"></script>
  <style>
    .highlight {
      background-color: red;
    }
  </style>
</head>
<body>
<div id="editorjs"></div>
<button onclick="highlightErrors()">Highlight Errors</button>

<script src="./spellCheck.js"></script>
<script>
  // Editor.js 초기화
  const editor = new EditorJS({
    holder: 'editorjs',
    tools: {
      // 사용 중인 툴들...
    },
    onReady: () => {
      addEventListenersToBlocks();
    },
    onChange: () => {
      setTimeout(() => {
        addEventListenersToBlocks();
      }, 0);
    },
  });
  let last_index = 1;

  // 변경이 있으면 호출
  function addEventListenersToBlocks() {
    console.log('길이', document.querySelectorAll('.ce-block__content').length);
    console.log('last_index', last_index);
    // 띄어쓰기의 경우도 해당 onChange로 일어나서 길이를 넘지 않게 처리하기
    if (document.querySelectorAll('.ce-block__content').length < last_index) {
      return;
    }
    // 블록 변경이 있으면 해당 함수 호출, event 를 다 모든 블럭에 다 지웠다 건다.
    // TODO: 다 거는게 아니라, 안된 것만 걸게 수정
    document.querySelectorAll('.ce-block__content').forEach((block, index) => {
      block.removeEventListener('keyup', handleCursorPosition);
      block.removeEventListener('click', handleCursorPosition);
      block.addEventListener('keyup', event => handleCursorPosition(event, index));
      block.addEventListener('click', event => handleCursorPosition(event, index));
      console.log('이벤트 리스너 추가', index);

      // 이게 새로 생긴 경우
      // TODO: 맞춤법 보내기
      if (index === last_index - 2) {
        console.log('이전 블록 문장', block.textContent);
        highlightErrorsBySentence(block);
      }
    });
    // 줄 추가 ++
    last_index += 1;
  }

  let previousText = ''; // 이전 입력 텍스트 저장 변수

  function handleCursorPosition(event, blockIndex) {
    const selection = window.getSelection();
    const range = selection.getRangeAt(0);
    const cursorPosition = range.startOffset;
    console.log(`Block index: ${blockIndex}, Cursor position: ${cursorPosition}`);
    const currentText = event.target.innerText;

    // 이전 텍스트와 현재 텍스트 비교하여 문장 부호 입력 여부 확인
    if (currentText.length > previousText.length) {
      const lastChar = currentText.slice(-1);
      if (lastChar === '.' || lastChar === '?' || lastChar === '!') {
        console.log(`Sentence ended in block ${blockIndex}`);
        console.log(`Text: ${currentText}`);
        // 여기서 원하는 추가적인 처리 수행 가능
      }
    }

    previousText = currentText; // 이전 텍스트 업데이트
  }

  // 입력으로 요청 보내기
  async function highlightErrorsBySentence(block) {
    const savedData = await editor.saver.save(); // 현재 데이터 저장
    console.log(savedData);
    // // 특정 블록 ID를 가진 블록을 찾아 업데이트
    // const blockss = savedData.blocks.find(block => block.id === blockId);
    const result = await spellCheck(block.textContent);
    console.log(result);

    // 토큰들 정규식으로 변경하기
    const errorTokens = result.map(entry => entry.token).join('|');
    const regex = new RegExp(`(${errorTokens})`, 'g');
    //
    const highlightedText = block.textContent.replace(regex, match => {
      return `<span class="highlight">${match}</span>`;
    });
    console.log(highlightedText);

  }

  async function highlightErrors() {
    // 에디터 내용을 가져오기
    const outputData = await editor.save();
    const textInput = outputData.blocks.map(block => block.data.text).join(' ');

    console.log('Before Check', outputData);
    const result = await spellCheck(textInput);

    // 토큰들 정규식으로 변경하기
    const errorTokens = result.map(entry => entry.token).join('|');
    const regex = new RegExp(`(${errorTokens})`, 'g');

    // 각 블록별로 처리하기
    const highlightedBlocks = outputData.blocks.map(block => {
      if (block.type === 'paragraph') {
        const highlightedText = block.data.text.replace(regex, match => {
          return `<span class="highlight" >${match}</span>`;
        });
        return {
          type: 'paragraph',
          data: {
            text: highlightedText,
          },
        };
      }
      return block;
    });

    // Editor.js에 하이라이트된 블록 설정
    editor.render({
      blocks: highlightedBlocks,
    });
  }
</script>
</body>
</html>
